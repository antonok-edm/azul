use super::{hsl_to_rgb, parse_color_builtin, ColorU, StyleBackground, GradientStopPre, Direction, ExtendMode, PercentageValue, FloatValue, LinearGradientPreInfo, DirectionCorner};

optspace = #quiet<[ \n\t]+>*
space = #quiet<[ \n\t]+>+
comma_sep = optspace "," optspace

hex1digit -> u8
    = d:$([a-fA-F0-9]) {?
        match u8::from_str_radix(d, 16) {
            Ok(d) => Ok(d * 17),
            Err(_) => Err("Component must be in the range [0-F]"),
        }
    }

hex2digit -> u8
    = d:$([a-fA-F0-9]*<2>) {?
        match u8::from_str_radix(d, 16) {
            Ok(d) => Ok(d),
            Err(_) => Err("Component must be in the range [00-FF]"),
        }
    }

hexcolor3 -> ColorU
    = "#" r:hex1digit g:hex1digit b:hex1digit {
        ColorU { r, g, b, a: 255 }
    }

hexcolor4 -> ColorU
    = "#" r:hex1digit g:hex1digit b:hex1digit a:hex1digit {
        ColorU { r, g, b, a }
    }

hexcolor6 -> ColorU
    = "#" r:hex2digit g:hex2digit b:hex2digit {
        ColorU { r, g, b, a: 255 }
    }

hexcolor8 -> ColorU
    = "#" r:hex2digit g:hex2digit b:hex2digit a:hex2digit {
        ColorU { r, g, b, a }
    }

hexcolor -> ColorU
    = hexcolor8 / hexcolor6 / hexcolor4 / hexcolor3

uint8 -> u8
    = u:$([0-9]*<1,3>) {?
        match u.parse() {
            Ok(u) => Ok(u),
            Err(_) => Err("Component must be in the range [0-255]"),
        }
    }

float -> f32
    = f:$("-"? [0-9]+ "."? [0-9]* / "-"? [0-9]* "."? [0-9]+) {?
        match f.parse() {
            Ok(f) => Ok(f),
            Err(_) => Err("Could not parse number as valid float"),
        }
    }

alpha -> u8
    = f:float {?
        if f > 1.0 || f < 0.0 {
            Err("Alpha must be in the range [0.0-1.0]")
        } else {
            Ok((f * 256.0 - 1.0) as u8)
        }
    }

rgbcolor -> ColorU
    = "rgb(" optspace r:uint8 comma_sep g:uint8 comma_sep b:uint8 optspace ")" {
        ColorU { r, g, b, a: 255 }
    }

rgbacolor -> ColorU
    = "rgba(" optspace r:uint8 comma_sep g:uint8 comma_sep b:uint8 comma_sep a:alpha optspace ")" {
        ColorU {r, g, b, a }
    }

angle -> f32
    = deg: (angle_deg / angle_grad / angle_rad) {
        let mut deg = deg % 360.0;
        if deg < 0.0 {
            deg += 360.0;
        }
        deg
    }

angle_deg -> f32
    = d:float optspace "deg" {
        d
    }

angle_grad -> f32
    = d:float optspace "grad" {
        d / 400.0 * 360.0
    }

angle_rad -> f32
    = d:float optspace "rad" {
        d * 180.0 / std::f32::consts::PI
    }

percent -> f32
    = p:float optspace "%" {
        p.max(0.0).min(100.0)
    }

hslcolor -> ColorU
    = "hsl(" optspace h:angle comma_sep s:percent comma_sep l:percent optspace ")" {
        let (r, g, b) = hsl_to_rgb(h, s, l);
        ColorU { r, g, b, a: 255 }
    }

hslacolor -> ColorU
    = "hsla(" optspace h:angle comma_sep s:percent comma_sep l:percent comma_sep a:alpha optspace ")" {
        let (r, g, b) = hsl_to_rgb(h, s, l);
        ColorU { r, g, b, a }
    }

builtincolor -> ColorU
    = input:$([a-zA-z\-]*) {?
        match parse_color_builtin(input) {
            Ok(c) => Ok(c),
            Err(_) => Err("Unknown color"),
        }
    }

/// Parses any string CSS color into a ColorU object
pub csscolor -> ColorU
    = hexcolor / rgbcolor / rgbacolor / hslcolor / hslacolor / builtincolor

/// Parses any string CSS color into a StyleBackground object
pub cssbackground -> StyleBackground
    = nobackground / linear_gradient //... repeating_linear_gradient / radial_gradient / repeating_radial_gradient / image

nobackground -> StyleBackground
    = "none" {
        StyleBackground::NoBackground
    }

linear_gradient -> StyleBackground
    = repeat:"repeating-"? "linear-gradient(" optspace d:(d:gradient_direction comma_sep {d})? firststop:gradient_stop comma_sep morestops:gradient_stop++ comma_sep ")" {
        let extend_mode = match repeat {
            Some(_) => ExtendMode::Repeat,
            None => ExtendMode::Clamp,
        };
        let mut stops = vec![firststop];
        morestops.iter().for_each(|stop| stops.push(*stop));
        let direction = match d {
            Some(d) => d,
            None => Direction::FromTo(DirectionCorner::Top, DirectionCorner::Bottom),
        };
        StyleBackground::LinearGradient(LinearGradientPreInfo {
            direction,
            extend_mode,
            stops
        })
    }

gradient_direction -> Direction
    = gradient_corner / (a:angle { Direction::Angle(FloatValue::new(a)) })

gradient_corner -> Direction
    = "to" space first:rectangle_side second:(space s:rectangle_side {s})? {?
        match second {
            None => {
                Ok(Direction::FromTo(first.opposite(), first))
            }
            Some(second) => {
                match first.combine(&second) {
                    Some(end) => Ok(Direction::FromTo(end.opposite(), end)),
                    None => Err("Could not combine corner arguments".into()),
                }
            }
        }
    }

rectangle_side -> DirectionCorner
    = left / right / bottom / top

left -> DirectionCorner
    = "left" { DirectionCorner::Left }

right -> DirectionCorner
    = "right" { DirectionCorner::Right }

bottom -> DirectionCorner
    = "bottom" { DirectionCorner::Bottom }

top -> DirectionCorner
    = "top" { DirectionCorner::Top }

gradient_stop -> GradientStopPre
    = color:csscolor optspace p:percent? {
        let offset = match p {
            Some(p) => Some(PercentageValue::new(p)),
            None => None
        };
        GradientStopPre {
            offset,
            color,
        }
    }
